
tort - Tiny Object RunTime

Inspired by Ian Piumarta's idst, maru and other small runtimes.

Core is approx. 3700 lines of C.

Supports:

* Primitive object types.
** String.
** Symbol.
** Method.
** Method table.
** Tagged integer.
** Vector.
** Pair.
** Map.
** IO with FILE* and finalization.
* Dynamic message dispatch.
** ~30,000,000 send/sec on OS X 64-bit using a global method cache.
** global method cache monitors for invalidations due to:
*** New method definitons using symbol version counters.
*** Changes in lookup() meta-send protocol method.
*** Changes in method table delegation.
* Meta-send protocol:
** Decomposed into lookup(message, receiver, ...), apply(message, receiver, ...).
** Fully recursive lookup() delegation.
** Message objects allocated on C stack.
** Supports tail recursion.
** Supports method aliasing.
* GC Support:
** NO GC (malloc-only).
** BDW GC library.
** SMAL GC library (PROTOTYPE).
* Low-bit tagging is configurable at compile-time.

Extensions are dynamically loaded:

* Dynamic library loading with automatic initialization, method installation.

* Example Extension Library.
** Lexical blocks in C using GCC nested functions.
** Fibers.
** Object graphing using graphviz/dot.
** Catch/throw support.

* LISP Extension Library.
** Conses.
** Lisp reader.
** Lisp writer.
** Lexicial evaluator.
** Simple macro support.
** Call-in and call-out to tort primitives.
*** Lambdas can be used as object methods.
*** Lambdas can be used as object blocks.
*** Methods can be called using ('symbol rcvr . args) syntax.
** Basic Scheme-like semantics boot-strapped from objects and lisp.
** Basic structures based on vectors.
** PRELIMINARY x86-64 compiler written in Scheme superset.
