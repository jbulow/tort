(define-struct isns
  (name      #f)
  (isns      (vector))
  (labels    ('new <map>))
  (label-id  0)
  (literals '())
  (pass      'unknown)
  (env       #f)
  (main      #f)
  )
(define-method isns ('lisp_write self port)
  (display "#<isns >" port))
(define-method isns ('emit self . isns)
  (let ((out ('isns self)))
    (for-each 
      (lambda (x)
	(if (not (pair? x)) (error "emit: not a pair: %O" x))
	;; (display "    | ")(display x)(newline)
	('add out x)) 
      isns))
  self)
(define-method isns ('label self . name)
  (set! name (if (pair? name) (car name) #f))
  ;; (debug "isns.label" name)
  (let ((id ('label-id self))
	 (label ('new label)))
    ('label-id= self (+ id 1))
    ('id= label id)
    (if name
      (begin
	('scope= label 'global)
	(set! name name))
      (set! name (string->symbol (string-append "L" (number->string id)))))
    ('name= label name)
    ('set ('labels self) name label)
    label))

(let ((output-name-id 0))
  (define-struct assembler
    (output-name 
      (let ((id (+ output-name-id 1)))
	(set! output-name-id id)
	(string-append "_tort_x_" (number->string id))))
    (_init-symbol #f)
    (_asm #f)
    (isns #f)
    (global-label-prefix (or (not-nil ('get &root 'dynlib_global_prefix)) "_"))
    (dynlib-suffix       (or (not-nil ('get &root 'dynlib_suffix)) ".dynlib"))
    )
  )
(define-method assembler ('init-symbol self)
  (let ((x ('_init-symbol self)))
    (if x x
      (begin
	(set! x (string->symbol ('output-name self)))
	('_init-symbol= self x)
	x))))

(define-method assembler ('asm self)
  (let ((o ('_asm self)))
    (if (not o)
      (letrec (
	(isn
	  (lambda (op . args)
	    (let ((sep " "))
	      (x op)
	      (for-each 
		(lambda (e)
		  (display sep o) (x e)
		  (set! sep ", "))
		args)
	      (newline o))))
	(isn-pic
	  (lambda (op . args)
	    (let ((sep " "))
	      (x op)
	      (for-each 
		(lambda (e)
		  (display sep o) (x e 'pic)
		  (set! sep ", "))
		args)
	      (newline o))))
        (x
          (lambda (e . pic)
	    (set! pic (and (pair? pic) (car pic)))
	    (cond
	      ((pair? e)
		(case (car e)
		  ((&r)  (display (cadr e) o))
		  ((&g)  (x (cadr e)))
		  ((&$)  (display "$" o) (display (cadr e) o))
		  ((&o)  (display (cadr e) o)
		         (display "(" o) (x (caddr e))
		         (display ")" o))
		  (else  (display e o))))
	      ((label? e)
		(if (eq? ('scope e) 'global)
		  (begin
		    (display ('global-label-prefix self) o)
		    (display ('name e) o)
		    (if pic
		      (display '@GOTPCREL o)))
		  (display ('name e) o))
		(if pic
		  (begin
		    (display "(" o)
		    (display '%rip o)
		    (display ")" o))
		  ))
	      (else
		(display e o))))))
	(set! o (string-new))
	('_asm= self o)
	(vector-for-each
	  (lambda (e)
	    ;; (display "  isn = ")(write e)(newline)
	    (case (car e)
	      ((.align)       (isn '.align (cadr e) "0x90"))
	      ((.globl)       (isn '.globl (cadr e)))
	      ((.label:)      (isn (cadr e) ':))
	      ((.text .data)  (isn (car e)))
	      ((callq*)       (isn "callq *" (cadr e)))
	      ((movq)         (isn-pic . e))
	      (else           (isn . e))))
	  ('isns ('isns self)))
	))
      o))

(define-method assembler ('assemble self . options)
  (let ((name ('output-name self))
	 (verbose (not (null? options)))
	 (fname '()))
    ;; (set! verbose #t)
    (set! fname (string-append "tmp/" name))
    (let ((sfile (string-append fname ".s"))
	   (ofile (string-append fname ".o"))
	   (dfile (string-append fname ('dynlib-suffix self))))
      ;;(display "sfile ")(write sfile)(newline)
      ;;(display "ofile ")(write ofile)(newline)
      (let ((name-sym (string->symbol name))
	     (st '())
	     (func-ptr '())
	     (result #f))
	(call-with-output-file sfile 
	  (lambda (f) (display ('asm self) f)))
	(if verbose
	  (begin
	    (display "Assembly:\n") 
	    (display ('asm self))
	    (display "=====\n")))
	
	(posix:system (string-append "gcc "
			;; (if verbose "--verbose" "")
			" -D__DYNAMIC__ -fPIC -DPIC "
			" -export-dynamic -fno-common -c -o " ofile " " sfile))
	;; (if verbose (posix:system (string-append "otool -tv " ofile)))
	(posix:system (string-append "gcc "
			;; (if verbose "--verbose" "")
			" -dynamiclib -Wl,-undefined -Wl,dynamic_lookup -o " dfile " " ofile " -compatibility_version 1 -current_version 1.0 -Wl,-single_module"))
	;; (if verbose (posix:system (string-append "otool -tv " dfile)))
	(set! result dfile)
	;; (posix:unlink sfile)
	;; (posix:unlink ofile)
	(display "'assemble => ")(write result)(newline)
	result
	))))

(define-method assembler ('load self . options)
  (let ((name ('output-name self))
	 (verbose (not (null? options)))
	 (fname '()))
    (set! verbose #t)
    (set! fname (string-append "tmp/" name))
    (let ((sfile (string-append fname ".s"))
	   (ofile (string-append fname ".o"))
	   (dfile (string-append fname ('dynlib-suffix self))))
      (let ((name-sym ('init-symbol self))
	     (st #f)
	     (func-ptr #f)
	     (result #f))
	(set! st ('load <dynlib> (string-append "./" dfile)))
	;;(display "st = ")(write st)(newline)
	;;(display "name-sym = ")(write name-sym)(newline)
	;;(display "name-sym class = ")(write (%get-type name-sym))(newline)
	;;('__debugger st) (set! &trace 1)
	(set! func-ptr ('get st name-sym))
	(if (or #t verbose) (begin (display "  func-ptr = ")(write func-ptr)(newline)))
	(set! result func-ptr)
	;; (posix:unlink dfile)
	result
	))))

