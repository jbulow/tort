(define-struct assembler
  (output-name #f)
  (_body #f)
  (isns #f)
  )

(define-method assembler ('body self)
  (let ((o ('_body self)))
    (if (not o)
      (letrec (
	(emit 
	  (lambda (op . args)
	    (let ((sep " "))
	      (display op o)
	      (for-each 
		(lambda (e)
		  (display sep o) (x e)
		  (set! sep ", "))
		args)
	      (newline o)
	      )))
        (x
          (lambda (e)
	    (cond
	      ((label? e)
		(display ('name e) o))
	      ((pair? e)
		(case (car e)
		  ((&r) (display (cadr e) o))
		  ((&$) (display "$" o) (display (cadr e) o))
		  ((&o) 
		    (display (cadr e) o)
		    (display "(" o) (x (caddr e)) (display ")" o))
		  (else
		    (display e o))
		  ))
	      (else
		(display e o)))))
		)
	(set! o (string-new))
	('_body= self o)
	(vector-for-each
	  (lambda (e)
	    ;; (display "  isn = ")(write e)(newline)
	    (case (car e)
	      ((.align)
		(emit ".align" (cadr e) "0x90"))
	      ((.globl)
		(emit ".globl" (cadr e)))
	      ((.label:)
		(emit (cadr e) ':))
	      ((.text .data)
		(emit (car e)))
	      ((call*)
		(emit "call *" (cadr e)))
	      (else
		(emit . e)
		)
	      )
	    )
	  ('isns ('isns self)))
	))
      o))

(define-method assembler ('assemble c . options)
  (let ((name ('output-name c))
	 (verbose (not (null? options)))
	 (fname '()))
    ;; (set! verbose #t)
    (set! fname (string-append "tmp/" name))
    (let ((sfile (string-append fname ".s"))
	   (ofile (string-append fname ".o"))
	   (dfile (string-append fname ".dylib"))
	   )
      ;;(display "sfile ")(write sfile)(newline)
      ;;(display "ofile ")(write ofile)(newline)
      (let ((name-sym (string->symbol name))
	     (st '())
	     (func-ptr '())
	     (result #f))
	(call-with-output-file sfile (lambda (f)
				       (display ('body c) f)))
	(if verbose
	  (begin
	    (display "Assembly:\n") 
	    (display ('body c))
	    (display "=====\n")))
	
	(posix:system (string-append "gcc "
			(if verbose "--verbose" "")
			" -D__DYNAMIC__ -fPIC -DPIC "
			" -export-dynamic -fno-common -c -o " ofile " " sfile))
	;; (if verbose (posix:system (string-append "otool -tv " ofile)))
	(posix:system (string-append "gcc "
			(if verbose "--verbose" "")
			" -dynamiclib -Wl,-undefined -Wl,dynamic_lookup -o " dfile " " ofile " -compatibility_version 1 -current_version 1.0 -Wl,-single_module"))
	;; (if verbose (posix:system (string-append "otool -tv " dfile)))
	(set! result dfile)
	;; (posix:unlink sfile)
	;; (posix:unlink ofile)
	(display "'assemble => ")(write result)(newline)
	result
	))))

(define-method assembler ('load c . options)
  (let ((name ('output-name c))
	 (verbose (not (null? options)))
	 (fname '()))
    (set! verbose #t)
    (set! fname (string-append "tmp/" name))
    (let ((sfile (string-append fname ".s"))
	   (ofile (string-append fname ".o"))
	   (dfile (string-append fname ".dylib"))
	   )
      (let ((name-sym (string->symbol name))
	     (st '())
	     (func-ptr '())
	     (result '()))
	(set! st ('load <dynlib> (string-append "./" dfile)))
	;;(display "st = ")(write st)(newline)
	;;(display "name-sym = ")(write name-sym)(newline)
	;;(display "name-sym class = ")(write (%get-type name-sym))(newline)
	;;('__debugger st) (set! &trace 1)
	(set! func-ptr ('get st name-sym))
	(if (or #t verbose) (begin (display "  func-ptr = ")(write func-ptr)(newline)))
	(set! result func-ptr)
	;; (posix:unlink dfile)
	result
	))))

